# build a udp socket implementing the quic multy flow/streams
# creating udp socket and sending 10 files
# each file will be 2 mb and will be generated by random data
# each file will be sent in a different stream
# The client will now send each file over a stream with a consistent chunk size per stream.
# The chunk size will be randomized between 1000 and 2000 bytes.
import os

# each packet contains frames from diffrent streams,where each stream have the same size of the quic packet
from quic import *
import socket
import threading
import time
import random
import string


class Client:
    def __init__(self, ip, port):  # Initialize the client with the server's IP and port
        self.server_address = (ip, port)
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.chunk_size = random.randint(1000, 2000)  # Consistent chunk size for each packet

    def generate_random_files(self, num_flows):
        """
                Generate random binary files for the given number of flows (streams).
                Each file is 2MB in size.

                :param num_flows: Number of files (streams) to generate.
                :return: List of generated file paths.
                """
        files = []
        file_size = 2 * 1024 * 1024  # 2MB in bytes
        for i in range(num_flows):
            file_name = f'random_file_{i}.txt'
            with open(file_name, 'w') as f:
                # Generate random bytes of size 2MB (2 * 1024 * 1024 bytes)
                random_data = ''.join(random.choices(string.ascii_letters + string.digits, k=file_size))
                f.write(random_data)
            files.append(file_name)
        return files

    def create_packet(self, packet_number, data, offsets, percentage=60):
        """
        Create a QUIC packet with frames from a percentage of streams.

        :param packet_number: The current packet number being sent.
        :param data: List of data streams (files) to send.
        :param offsets: List of current offsets for each stream.
        :param percentage: Percentage of streams to include in each packet (default is 60%).
        :return: A tuple containing the created packet, updated data list, and updated offsets.
        """
        flags = 0b00000010  # Data flag indicating this packet contains data frames

        # Determine the number of streams to include based on the given percentage
        full_data_len = 10
        frame_percentage = round(full_data_len * (percentage / 100))
        frames_num = min(frame_percentage, len(data))

        # Calculate the size of each frame based on the total packet size divided by the number of frames
        frame_size = round(self.chunk_size / frames_num)

        frames = []  # List to hold frames that will be included in this packet

        streams_to_remove = []


        # Iterate through the selected streams to add their data to the packet
        for i in range(frames_num):
            stream_id = len(data) - 1

            stream_data = data[stream_id]  # Get the stream ID and its corresponding data

            # Extract a chunk of data from the current offset up to the calculated frame size
            chunk_data = stream_data[offsets[stream_id]:offsets[stream_id] + frame_size]

            # Create a frame with the extracted data, including stream ID, offset, and data length
            frames.append(Frame(stream_id + 1, offsets[stream_id], len(chunk_data), chunk_data))

            # Update the offset for this stream to the next chunk

            offsets[stream_id] += len(chunk_data)

            # If the entire stream has been sent, remove it from the data list
            if offsets[stream_id] >= len(stream_data):
                print("__________________Stream {} has been fully sent___________________________--".format(stream_id))
                streams_to_remove.append(stream_id)
                data.pop(stream_id)
                offsets.pop(stream_id)

            stream_id -= 1

        #     # Remove fully sent streams from the data list and corresponding offsets in reverse order
        # for stream_id in sorted(streams_to_remove, reverse=True):
        #     data.pop(stream_id)
        #     offsets.pop(stream_id)

        # Create a QUIC packet with the specified header and the frames created above
        packet = Quic_packet(flags=flags, packet_number=packet_number, connection_id=1, frames=frames)
        return packet, data, offsets

    def send_packet(self, packet):
        """
        Send the given packet to the server.

        :param packet: The QUIC packet to be sent.
        """
        serialized_packet = packet.serialize()
        self.client_socket.sendto(serialized_packet, self.server_address)
        # print(f"Sent packet to {self.server_address} with packet number {packet.header.packet_number}")

    def send_all_packets(self, data):
        """
        Loop to create and send packets until all data from all streams is fully transmitted.

        :param data: List of data streams (files) to send.
        """
        packet_number = 1  # Initialize packet number


        # Initialize offsets for each stream; these track how much of each stream has been sent
        offsets = [0 for _ in range(len(data))]

        # Continue sending packets until all streams have been fully sent
        while data:
            # Create a packet containing parts of each stream, update data and offsets
            packet, data, offsets = self.create_packet(packet_number, data, offsets)

            # Serialize and send the packet to the server
            self.send_packet(packet)

            # Optional: Add a small delay between packet sends
            time.sleep(0.0001)  # Adjust as needed for timing

            packet_number += 1  # Increment packet number for the next packet

        print("All data has been sent")
        self.send_fin_massage(self.server_address, packet_number, 1)

    def send_syn(self):
        """
               Send a SYN packet to initiate the connection with the server.
         """
        # Set up a QUIC packet with the SYN flag set (assuming SYN is the first bit)
        flags = 0b00000001  # SYN flag
        packet_number = 1
        connection_id = 1
        # frame will contain the word "SYN"
        frame = Frame(1, 0, 3, "SYN")

        packet = Quic_packet(flags, packet_number, connection_id, [frame])
        serialized_packet = packet.serialize()
        self.client_socket.sendto(serialized_packet, self.server_address)
        print(f"Sent SYN packet to {self.server_address} with flags {flags}")

    def receive_ack(self):
        """
                Receive an ACK packet from the server to confirm the connection.
         """
        data, server_address = self.client_socket.recvfrom(1024)
        print(f"Received packet from {server_address}")
        packet = Quic_packet.deserialize(data)

        if packet.header.flags & 0b00000011:
            print(
                f"Received packet with packet number {packet.header.packet_number} and connection ID {packet.header.connection_id} and data {packet.frames[0].data}")

    def close(self):
        """
                Close the client socket connection.
         """
        self.client_socket.close()

    def send_fin_massage(self, server_address, packet_number, connection_id):
        flags = 0b00000100
        frame = Frame(1, 0, 3, "FIN")
        packet = Quic_packet(flags, packet_number, connection_id, [frame])
        serialized_packet = packet.serialize()
        self.client_socket.sendto(serialized_packet, server_address)
        print(f"Sent FIN packet to {server_address}")


if __name__ == "__main__":
    client = Client("localhost", 12346)
    client.send_syn()
    client.receive_ack()
    num_files = 10  # Number of files
    files = client.generate_random_files(num_files)  # Generate 10 random files

    # Load the content of the generated files into memory
    data = [open(file, 'r').read() for file in files]
    client.send_all_packets(data)  # Send packets until all files are fully transmitted

    client.close()  # Close the connection

# import socket
# import threading
# from flow import Flow
# from statistics import display_statistics
# import random
# import time
#
# class QUICClient:
#     def __init__(self, host, port):
#         self.host = host
#         self.port = port
#         self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#
#     def start(self, flows):
#         self.client_socket.connect((self.host, self.port))
#         self.client_socket.send(str(len(flows)).encode())
#
#         for flow in flows:
#             self.client_socket.send(flow.flow_id.encode())
#             self.client_socket.send(str(flow.packet_size).encode())
#             self.client_socket.send(str(flow.num_packets).encode())
#             threading.Thread(target=self.receive_flow, args=(flow,)).start()
#
#     def receive_flow(self, flow):
#         total_received_bytes = 0
#         start_time = time.time()
#         for _ in range(flow.num_packets):
#             data = self.client_socket.recv(flow.packet_size)
#             total_received_bytes += len(data)
#         end_time = time.time()
#         flow.total_bytes = total_received_bytes
#         flow.start_time = start_time
#         flow.end_time = end_time
#         print(f"Flow {flow.flow_id}: Received {total_received_bytes} bytes in {end_time - start_time} seconds")
#
# if __name__ == "__main__":
#     flows = [Flow(str(i), random.randint(1000, 2000), 100) for i in range(10)]
#     client = QUICClient("localhost", 12345)
#     client.start(flows)
#     time.sleep(5)  # Give some time for all threads to complete
#     display_statistics(flows)
