# build a udp socket implementing the quic multy flow/streams
# creating udp socket and sending 10 files
# each file will be 2 mb and will be generated by random data
# each file will be sent in a different stream
# The client will now send each file over a stream with a consistent chunk size per stream.
# The chunk size will be randomized between 1000 and 2000 bytes.

# each packet contains frames from diffrent streams,where each stream have the same size of the quic packet
from quic import *
import socket
import threading
import time
import random

class Client:
    def __init__(self, ip, port):
        self.server_address = (ip, port)
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def send_syn(self):
        # Set up a QUIC packet with the SYN flag set (assuming SYN is the first bit)
        flags = 0b00000001  # SYN flag
        packet_number = 1
        connection_id = 1
        # frame will contain the word "SYN"
        frame = Frame(1, 0, 3, "SYN")

        packet = Quic_packet(flags, packet_number, connection_id, [frame])
        serialized_packet = packet.serialize()
        self.client_socket.sendto(serialized_packet, self.server_address)
        print(f"Sent SYN packet to {self.server_address} with flags {flags}")

    def send_flow(self):
        ## Send multiple flows (files) to the server
        for flow_id in range(self.num_flows):  # Iterate over each flow
            ## Create random data with a random length between 1000 and 2000 bytes
            data = "Random data " * (random.randint(1000, 2000) // len("Random data "))

            offset = 0  ## Start from 0 to track the current position in the data
            packet_size = random.randint(1000, 2000)  # Random packet size between 1000 and 2000 bytes
            while offset < len(data):  ## Continue while there is data to send
                ## Slice the data into chunks of size packet_size
                chunk = data[offset:offset + packet_size]

                ## Create a Frame with the flow ID, current offset, length of current chunk, and the chunk data
                frame = Frame(flow_id, offset, len(chunk), chunk)

                ## Create a Quic_packet with DATA flag, packet ID, connection ID, and the Frame data
                packet = Quic_packet(0b00000010, flow_id, 1, [frame])  # DATA flag

                ## Serialize the packet into the required format for sending
                serialized_packet = packet.serialize()

                ## Send the packet to the server
                self.client_socket.sendto(serialized_packet, self.server_address)

                ## Update the current offset in the data
                offset += packet_size

                ## Print information about the sent packet
                print(f"Sent packet for flow {flow_id} with offset {offset} and packet size {packet_size}")

    def receive_ack(self):
        data, server_address = self.client_socket.recvfrom(1024)
        print(f"Received packet from {server_address}")
        packet = Quic_packet.deserialize(data)

        if packet.header.flags & 0b00000011:
            print(
                f"Received packet with packet number {packet.header.packet_number} and connection ID {packet.header.connection_id} and data {packet.frames[0].data}")

    def close(self):
        self.client_socket.close()


if __name__ == "__main__":
    client = Client("localhost", 12346)
    client.send_syn()
    client.receive_ack()
    time.sleep(5)
    client.close()

# import socket
# import threading
# from flow import Flow
# from statistics import display_statistics
# import random
# import time
#
# class QUICClient:
#     def __init__(self, host, port):
#         self.host = host
#         self.port = port
#         self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#
#     def start(self, flows):
#         self.client_socket.connect((self.host, self.port))
#         self.client_socket.send(str(len(flows)).encode())
#
#         for flow in flows:
#             self.client_socket.send(flow.flow_id.encode())
#             self.client_socket.send(str(flow.packet_size).encode())
#             self.client_socket.send(str(flow.num_packets).encode())
#             threading.Thread(target=self.receive_flow, args=(flow,)).start()
#
#     def receive_flow(self, flow):
#         total_received_bytes = 0
#         start_time = time.time()
#         for _ in range(flow.num_packets):
#             data = self.client_socket.recv(flow.packet_size)
#             total_received_bytes += len(data)
#         end_time = time.time()
#         flow.total_bytes = total_received_bytes
#         flow.start_time = start_time
#         flow.end_time = end_time
#         print(f"Flow {flow.flow_id}: Received {total_received_bytes} bytes in {end_time - start_time} seconds")
#
# if __name__ == "__main__":
#     flows = [Flow(str(i), random.randint(1000, 2000), 100) for i in range(10)]
#     client = QUICClient("localhost", 12345)
#     client.start(flows)
#     time.sleep(5)  # Give some time for all threads to complete
#     display_statistics(flows)